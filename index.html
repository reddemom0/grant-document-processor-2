<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grant Document Processor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            color: #333;
            margin: 10px 0;
            font-size: 24px;
        }
        
        .subtitle {
            color: #666;
            font-size: 16px;
            margin-bottom: 20px;
        }
        
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background-color: #fafafa;
        }
        
        .upload-area:hover {
            border-color: #4A90C2;
            background-color: #f0f8ff;
        }
        
        input[type="file"] {
            margin: 10px 0;
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            margin: 10px 0;
            box-sizing: border-box;
        }
        
        button {
            background: #4A90C2;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        
        button:hover {
            background: #357ABD;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            display: none;
        }
        
        .status.info {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            color: #0066cc;
        }
        
        .status.success {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            color: #2e7d32;
        }
        
        .status.error {
            background: #ffeaea;
            border: 1px solid #f44336;
            color: #c62828;
        }
        
        .results {
            margin-top: 30px;
            display: none;
        }
        
        .chunk {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .chunk-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chunk-content {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            padding: 10px;
            border-radius: 3px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .copy-btn {
            padding: 5px 10px;
            font-size: 12px;
            background: #28a745;
            border: none;
            border-radius: 3px;
            color: white;
            cursor: pointer;
        }
        
        .copy-btn:hover {
            background: #218838;
        }
        
        .summary {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .summary h3 {
            margin-top: 0;
            color: #856404;
        }
        
        .manual-input {
            background: #e8f4fd;
            border: 1px solid #4A90C2;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        .manual-input h3 {
            margin-top: 0;
            color: #2c5aa0;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <svg class="logo" viewBox="0 0 400 120" xmlns="http://www.w3.org/2000/svg" style="max-width: 300px; height: auto; margin-bottom: 20px;">
                <text x="50" y="40" font-family="Arial, sans-serif" font-size="32" font-weight="300" fill="#888">
                    GR
                </text>
                <text x="110" y="40" font-family="Arial, sans-serif" font-size="32" font-weight="300" fill="#4A90C2">
                    A
                </text>
                <text x="140" y="40" font-family="Arial, sans-serif" font-size="32" font-weight="300" fill="#888">
                    NTED
                </text>
                
                <text x="200" y="50" font-family="Arial, sans-serif" font-size="14" font-weight="300" fill="#888" letter-spacing="3">
                    CONSULTING
                </text>
                
                <path d="M 50 50 Q 70 45 90 50 Q 70 55 50 50" stroke="#4A90C2" stroke-width="2" fill="none"/>
                <path d="M 55 55 Q 75 50 95 55 Q 75 60 55 55" stroke="#4A90C2" stroke-width="1.5" fill="none" opacity="0.7"/>
                <path d="M 60 60 Q 80 55 100 60 Q 80 65 60 60" stroke="#4A90C2" stroke-width="1" fill="none" opacity="0.5"/>
            </svg>
            
            <h1>Grant Document Processor</h1>
            <p class="subtitle">Extract and prepare grant documents for CustomGPT.ai grant criteria analysis</p>
        </div>
        
        <div class="upload-area">
            <h3>Upload Grant Document</h3>
            <p>Select a PDF file to extract and process text for CustomGPT.ai</p>
            <input type="file" id="fileInput" accept=".pdf" />
            <br>
            <button onclick="processDocument()" id="processBtn">Process PDF</button>
        </div>
        
        <div class="manual-input">
            <h3>Or Paste Text Directly</h3>
            <p>If you already have the text from your grant document, paste it below:</p>
            <textarea id="manualText" placeholder="Paste your grant document text here..."></textarea>
            <button onclick="processManualText()" id="manualBtn">Process Text</button>
        </div>
        
        <div id="status" class="status"></div>
        
        <div id="results" class="results">
            <div id="summary" class="summary" style="display: none;">
                <h3>Processing Summary</h3>
                <p id="summaryText"></p>
            </div>
            
            <div id="chunks"></div>
        </div>
    </div>

    <script>
        const MAX_CHUNK_SIZE = 7500;
        
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
            statusDiv.style.display = 'block';
        }
        
        async function processDocument() {
            const fileInput = document.getElementById('fileInput');
            const processBtn = document.getElementById('processBtn');
            
            if (!fileInput.files[0]) {
                showStatus('Please select a PDF file first', 'error');
                return;
            }
            
            if (!fileInput.files[0].type.includes('pdf')) {
                showStatus('Please select a PDF file', 'error');
                return;
            }
            
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';
            showStatus('Extracting text from PDF...', 'info');
            
            try {
                const extractedText = await extractTextFromPDF(fileInput.files[0]);
                showStatus('Text extracted! Filtering and analyzing...', 'info');
                await processExtractedText(extractedText);
                showStatus('Document processed successfully!', 'success');
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = 'Process PDF';
            }
        }
        
        async function processManualText() {
            const textArea = document.getElementById('manualText');
            const manualBtn = document.getElementById('manualBtn');
            
            const text = textArea.value.trim();
            if (!text) {
                showStatus('Please paste some text first', 'error');
                return;
            }
            
            manualBtn.disabled = true;
            manualBtn.textContent = 'Processing...';
            showStatus('Filtering and analyzing text...', 'info');
            
            try {
                await processExtractedText(text);
                showStatus('Text processed successfully!', 'success');
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            } finally {
                manualBtn.disabled = false;
                manualBtn.textContent = 'Process Text';
            }
        }
        
        async function extractTextFromPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            
            let fullText = '';
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                
                // Better formatting preservation
                const pageItems = textContent.items;
                let pageText = '';
                let lastY = null;
                let lineText = '';
                
                for (let i = 0; i < pageItems.length; i++) {
                    const item = pageItems[i];
                    const currentY = Math.round(item.transform[5]);
                    
                    // If we're on a new line (different Y coordinate)
                    if (lastY !== null && Math.abs(currentY - lastY) > 2) {
                        if (lineText.trim()) {
                            pageText += lineText.trim() + '\n';
                        }
                        lineText = '';
                    }
                    
                    // Add space if this item is far from the previous one horizontally
                    if (lineText && item.transform[4] > 0) {
                        const prevItem = pageItems[i - 1];
                        if (prevItem && (item.transform[4] - (prevItem.transform[4] + prevItem.width)) > 10) {
                            lineText += ' ';
                        }
                    }
                    
                    lineText += item.str;
                    lastY = currentY;
                }
                
                // Add the last line
                if (lineText.trim()) {
                    pageText += lineText.trim() + '\n';
                }
                
                fullText += pageText + '\n';
            }
            
            if (!fullText.trim()) {
                throw new Error('No text could be extracted from the PDF');
            }
            
            // Preserve bullet points and list formatting
            fullText = fullText
                .replace(/•/g, '• ') // Ensure space after bullets
                .replace(/^\s*\d+\.\s*/gm, function(match) { // Preserve numbered lists
                    return match;
                })
                .replace(/^\s*[a-z]\)\s*/gm, function(match) { // Preserve lettered lists
                    return match;
                });
            
            return fullText.trim();
        }
        
        function filterUnnecessaryContent(text) {
            let filtered = text;
            
            // Stage 1: Remove only the most obvious waste - table of contents with dots
            filtered = filtered.replace(/contents[\s\S]*?\.{3,}[\s\S]*?(?=program overview|eligible|overview|description)/gi, '');
            
            // Stage 2: Remove page references and dot leaders only
            filtered = filtered.replace(/\.{4,}/g, ''); // Remove long dot patterns
            filtered = filtered.replace(/\s+\d+\s*$/gm, ''); // Remove trailing page numbers only
            
            // Stage 3: Remove only administrative headers (keep content)
            filtered = filtered.replace(/effective\s+\w+\s+\d+\s*,?\s*\d{4}/gi, '');
            filtered = filtered.replace(/\d{4}\/\d{2,4}/g, '');
            
            // Stage 4: Remove website URLs only (keep references to appendices and content)
            filtered = filtered.replace(/https?:\/\/[^\s]+/g, '[WEBSITE]');
            filtered = filtered.replace(/www\.[^\s]+/g, '[WEBSITE]');
            
            // Stage 5: Clean up excessive whitespace but preserve structure
            filtered = filtered.replace(/\n{4,}/g, '\n\n\n'); // Allow up to 3 line breaks
            filtered = filtered.replace(/[ \t]{4,}/g, '  '); // Keep some spacing for tables
            
            // Stage 6: Preserve bullet points and list formatting
            // Don't remove bullets, numbers, or indentation that could be lists
            
            // Stage 7: Only remove lines that are clearly just administrative waste
            filtered = filtered.split('\n').filter(line => {
                const lineTrimmed = line.trim().toLowerCase();
                return !(
                    /^\.{3,}/.test(line) || // Lines starting with dots only
                    /^\d+$/.test(lineTrimmed) || // Just standalone page numbers
                    /^page\s+\d+/.test(lineTrimmed) || // Page references
                    /^\d{4}\/\d+$/.test(lineTrimmed) // Date patterns only
                );
            }).join('\n');
            
            // Stage 8: Final cleanup - minimal
            filtered = filtered.replace(/\n\s*\n\s*\n\s*\n/g, '\n\n\n'); // Max 3 line breaks
            
            return filtered.trim();
        }
        
        async function processExtractedText(text) {
            const charCount = text.length;
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            const summaryText = document.getElementById('summaryText');
            const chunksDiv = document.getElementById('chunks');
            
            chunksDiv.innerHTML = '';
            resultsDiv.style.display = 'block';
            summaryDiv.style.display = 'block';
            
            const filteredText = filterUnnecessaryContent(text);
            const reductionPercent = Math.round((1 - filteredText.length / text.length) * 100);
            const keyFacts = extractKeyFacts(filteredText);
            const documentType = analyzeDocumentType(filteredText);
            
            if (filteredText.length <= MAX_CHUNK_SIZE) {
                summaryText.innerHTML = '<strong>Original Length:</strong> ' + charCount.toLocaleString() + ' characters<br>' +
                    '<strong>Filtered Length:</strong> ' + filteredText.length.toLocaleString() + ' characters (' + reductionPercent + '% reduction)<br>' +
                    '<strong>Document Type:</strong> ' + documentType + '<br>' +
                    '<strong>Processing Method:</strong> Single message<br>' +
                    '<strong>Ready for:</strong> Direct copy/paste to CustomGPT.ai';
                
                createChunkElement(filteredText, 1, 1, 'Complete Document', keyFacts, documentType);
            } else {
                const chunks = smartChunkText(filteredText);
                
                summaryText.innerHTML = '<strong>Original Length:</strong> ' + charCount.toLocaleString() + ' characters<br>' +
                    '<strong>Filtered Length:</strong> ' + filteredText.length.toLocaleString() + ' characters (' + reductionPercent + '% reduction)<br>' +
                    '<strong>Document Type:</strong> ' + documentType + '<br>' +
                    '<strong>Processing Method:</strong> ' + chunks.length + ' chunks<br>' +
                    '<strong>Key Facts:</strong> ' + keyFacts.length + '<br>' +
                    '<strong>Instructions:</strong> Copy and paste each chunk sequentially to CustomGPT.ai';
                
                chunks.forEach(function(chunk, index) {
                    createChunkElement(chunk, index + 1, chunks.length, 'Chunk ' + (index + 1), keyFacts, documentType);
                });
            }
        }
        
        function extractKeyFacts(text) {
            const facts = [];
            
            const fundingMatch = text.match(/(?:funding|grant value|amount|up to|maximum)[:\s]*\$?([0-9,]+(?:\.[0-9]{2})?)/i);
            if (fundingMatch) {
                facts.push('Funding: $' + fundingMatch[1]);
            }
            
            const percentMatch = text.match(/(\d+)%\s*(?:of|coverage|reimbursement|funding)/i);
            if (percentMatch) {
                facts.push('Coverage: ' + percentMatch[1] + '%');
            }
            
            const deadlineMatch = text.match(/(?:deadline|due|timeline|turnaround)[:\s]*([0-9-]+ (?:days|weeks|months|business days))/i);
            if (deadlineMatch) {
                facts.push('Timeline: ' + deadlineMatch[1]);
            }
            
            return facts;
        }
        
        function analyzeDocumentType(text) {
            const indicators = {
                'Training Grant': ['training', 'skill development', 'workforce'],
                'R&D Grant': ['research', 'development', 'innovation', 'technology'],
                'Market Expansion Grant': ['export', 'international', 'market expansion'],
                'Hiring Grant': ['hiring', 'employment', 'wage subsidy'],
                'Business Loan': ['loan', 'financing', 'credit'],
                'Investment Program': ['investment', 'equity', 'capital funding']
            };
            
            const textLower = text.toLowerCase();
            let bestMatch = 'General Grant';
            let maxScore = 0;
            
            for (const type in indicators) {
                const keywords = indicators[type];
                const score = keywords.reduce(function(acc, keyword) {
                    return acc + (textLower.includes(keyword) ? 1 : 0);
                }, 0);
                
                if (score > maxScore) {
                    maxScore = score;
                    bestMatch = type;
                }
            }
            
            return bestMatch;
        }
        
        function smartChunkText(text) {
            const chunks = [];
            let remainingText = text;
            
            while (remainingText.length > 0) {
                if (remainingText.length <= MAX_CHUNK_SIZE) {
                    chunks.push(remainingText.trim());
                    break;
                }
                
                const splitPoint = findBestSplitPoint(remainingText);
                const chunk = remainingText.substring(0, splitPoint).trim();
                
                if (chunk) {
                    chunks.push(chunk);
                }
                
                remainingText = remainingText.substring(splitPoint).trim();
            }
            
            return chunks;
        }
        
        function findBestSplitPoint(text) {
            const maxLength = MAX_CHUNK_SIZE;
            if (text.length <= maxLength) {
                return text.length;
            }
            
            const searchStart = Math.max(0, maxLength - 300);
            const breakPoints = [
                text.lastIndexOf('\n\n', maxLength),
                text.lastIndexOf('. ', maxLength),
                text.lastIndexOf('\n', maxLength),
                text.lastIndexOf(' ', maxLength)
            ];
            
            for (let i = 0; i < breakPoints.length; i++) {
                if (breakPoints[i] > searchStart) {
                    return breakPoints[i] + 1;
                }
            }
            
            return maxLength;
        }
        
        function createChunkElement(content, chunkNumber, totalChunks, title, keyFacts, documentType) {
            const chunksDiv = document.getElementById('chunks');
            const chunkDiv = document.createElement('div');
            chunkDiv.className = 'chunk';
            
            const keyFactsText = keyFacts && keyFacts.length > 0 ? 
                '\n🔑 KEY FACTS: ' + keyFacts.join(' | ') + '\n' : '';
            
            let promptText;
            if (totalChunks === 1) {
                promptText = 'Analyze this ' + (documentType || 'grant').toLowerCase() + 
                ' document and create grant criteria following the GRANT-CRITERIA-Formatter instructions:' + 
                keyFactsText + '\n\n' + content;
            } else if (chunkNumber === 1) {
                promptText = '📋 MULTI-PART GRANT DOCUMENT - ' + (documentType || 'GRANT').toUpperCase() + '\n\n' +
                'I will provide this grant document in ' + totalChunks + ' parts. Following your GRANT-CRITERIA-Formatter training:\n\n' +
                '🧠 INSTRUCTIONS:\n' +
                '1. ACKNOWLEDGE each part received\n' +
                '2. SUMMARIZE key information from each part\n' +
                '3. DO NOT create grant criteria until you have ALL parts\n' +
                '4. Search ENTIRE document across all parts for each field\n\n' +
                keyFactsText +
                '📋 PART ' + chunkNumber + ' OF ' + totalChunks + ':\n' +
                '═'.repeat(50) + '\n' +
                content + '\n' +
                '═'.repeat(50) + '\n\n' +
                '✅ RESPONSE: "Part ' + chunkNumber + ' received. Key info: [summarize]. Ready for Part ' + (chunkNumber + 1) + '."';
            } else if (chunkNumber === totalChunks) {
                promptText = '📋 FINAL PART ' + chunkNumber + ' OF ' + totalChunks + ':\n' +
                '═'.repeat(50) + '\n' +
                content + '\n' +
                '═'.repeat(50) + '\n\n' +
                '🎯 CREATE GRANT CRITERIA\n\n' +
                'You now have ALL ' + totalChunks + ' parts. Key facts:\n' +
                keyFactsText + '\n' +
                'Create comprehensive grant criteria using information from ALL parts (1-' + totalChunks + ').\n' +
                'Follow exact field structure for ' + (documentType || 'the identified grant type') + '.';
            } else {
                promptText = '📋 PART ' + chunkNumber + ' OF ' + totalChunks + ':\n' +
                '═'.repeat(50) + '\n' +
                content + '\n' +
                '═'.repeat(50) + '\n\n' +
                'STATUS: Parts 1-' + chunkNumber + ' of ' + totalChunks + '\n' +
                keyFactsText +
                '✅ RESPONSE: "Part ' + chunkNumber + ' received. Summary: [brief]. Ready for Part ' + (chunkNumber + 1) + '."\n\n' +
                '🚫 Do NOT create grant criteria yet.';
            }
            
            const chunkHeader = document.createElement('div');
            chunkHeader.className = 'chunk-header';
            
            const titleSpan = document.createElement('span');
            titleSpan.textContent = title + ' (' + content.length.toLocaleString() + ' characters)';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-btn';
            copyBtn.textContent = 'Copy for CustomGPT.ai';
            copyBtn.onclick = function() { 
                copyToClipboard(copyBtn, promptText); 
            };
            
            chunkHeader.appendChild(titleSpan);
            chunkHeader.appendChild(copyBtn);
            
            const chunkContent = document.createElement('div');
            chunkContent.className = 'chunk-content';
            chunkContent.textContent = promptText;
            
            chunkDiv.appendChild(chunkHeader);
            chunkDiv.appendChild(chunkContent);
            chunksDiv.appendChild(chunkDiv);
        }
        
        async function copyToClipboard(button, text) {
            try {
                await navigator.clipboard.writeText(text);
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = '#28a745';
                
                setTimeout(function() {
                    button.textContent = originalText;
                    button.style.background = '#28a745';
                }, 2000);
            } catch (error) {
                button.textContent = 'Copied!';
                setTimeout(function() {
                    button.textContent = 'Copy for CustomGPT.ai';
                }, 2000);
            }
        }
    </script>
</body>
</html>
